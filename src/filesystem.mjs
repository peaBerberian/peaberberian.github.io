// TODO: Make base mostly work even without `IndexededDB` API (just do not store
// long term in that case)
/**
 * # The FileSystem
 *
 * This file defines our "filesystem".
 *
 * It follows the old unix way of doing `/` stuff but with many many
 * simplfications in some ways and specificities in other due to the nature of
 * the site.
 *
 * The root directory is `/` and can be read through the `readDir` API.
 * It is read-only.
 *
 *
 *
 * ## Directories at the root
 *
 * The root directory contains itself the following directories.
 *
 *
 * ### `/apps/`
 *
 * The `/apps/` root  contains virtual "executable" files corresponding to this
 * desktop's application. They are not actually stored on long term storage on
 * the user's device, they are embedded inside the JS files.
 *
 * Each "file" in that directory is an actual app. This whole directory is
 * read-only: no file can be removed, moved or renamed. No file can be added to
 * this directory. Doing any of this will lead to an error.
 *
 * #### Reading the `/apps/` dir
 *
 * When reading the dir, e.g. through `readDir`, you'll get an Array of objects
 * corresponding to the list of ""installed"" applications.
 *
 * Each returned object will have the following properties:
 *
 * -  Its `name` property is the actual application's `id` property, followed by
 *    the extension `.run` (e.g. `paint.run`)
 *
 * -  Its `icon` property wll correspond to the application's `icon` property.
 *
 * -  Its `type` property set to `file`.
 *
 * -  Its `modified` property set to some hardcoded old date.
 *
 * #### Reading a file from `/apps/`
 *
 * When reading a file in `/apps/` e.g. `/apps/about.run`, the returned
 * information will contain the corresponding app object in
 * `./__generated_apps.mjs` that contains everything that's needed to run it.
 *
 * It's basically the executable format of this desktop: a JSON/JS object with
 * some set properties defining different aspects of the app (wanted
 * width/height, where to find its code etc.).
 *
 *
 * ### `/system/`
 *
 * `/system/` is also a read-only root directory. It contains basically
 * virtual "config files" for the desktop.
 *
 * It is for now read-only, as well as all its content. However the whole point
 * is here to make it configurable in the future, I just didn't take the time
 * yet.
 *
 * For now it contains the following files (with the `type` set to `file`), they
 * can be discovered through `readDir`, but they should be always there:
 *
 * -  `/system/desktop.config.json`: Contains metadata on the wanted arrangement
 *    for the desktop icons.
 *
 *    Reading that file will return you a JSON object.
 *    That object will contain a `list` key containing an Array of JSON objects,
 *    each representing an application to display on the desktop, in the given
 *    order they should be ordered, with the following keys:
 *
 *    -  `run` (`string`): The path to the application "executable" (e.g.
 *       `/apps/paint.run`).
 *
 *    -  `title` (`string`): The `title` of the application to show on the
 *       desktop.
 *
 *    - `icon` (`string|undefined`): The icon to show for the application.
 *
 *    - `desktopDir` (`string|undefined`): If set, the application should be
 *      put in an "app group" with the corresponding name, not directly on the
 *      desktop.
 *
 * -  `system/start_menu.config.json`: Contains metadata for the arrangement of
 *    apps in the start menu
 *
 *    Reading that file will return you a JSON object,
 *    That object will contain a `list` key containing an Array of JSON objects,
 *    each representing an application to display on that menu, in the given
 *    order they should be ordered, with the following keys:
 *
 *    -  `run` (`string`): The path to the application (e.g. `/apps/about.run`).
 *
 *    -  `title` (`string`): The `title` of the application to show on the
 *       start menu.
 *
 *    - `icon` (`string|undefined`): The icon to show for the application.
 *
 *    - `inStartList` (`string|undefined`): If set, the application should be
 *      part of a sublist in the start menu, with the corresponding name.
 *
 * ### `/userdata/`
 *
 * The root directory where the user can do whatever it wants: read/write.
 * Not decided yet on its content.
 */

// We first import app-utils as a library for Applications that we're going
// to load just now.
import "./app-utils.mjs";
// /!\ Apps file is automatically generated by the build script
import apps from "./__generated_apps.mjs";

const DB_NAME = "fake_filesystem";
const DB_VERSION = 1;

const METADATA_STORE = "files";
const CONTENT_STORE = "files_content";

const DIR_CONFIG_FILENAME = ".dir_config";

const APPS_DIR = "/apps/";
const SYSTEM_DIR = "/system/";
const USER_DATA_DIR = "/userdata/";

const DEFAULT_MODIFIED_DATE = 1747073021004;

const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();

// TODO: check consistency at startup?

class DesktopFileSystem {
  constructor() {
    this._dbProm = openDB();
    this._virtualRootDirs = [APPS_DIR, SYSTEM_DIR];
  }

  async writeFile(path, content) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    if (path.endsWith("/")) {
      throw new Error(
        "Calling `writeFile` to write a directory. Use `mkdir` instead.",
      );
    }

    const name = getName(path);
    if (name === DIR_CONFIG_FILENAME) {
      throw new Error("Using a reserved system name");
    }

    if (/[\x00-\x1F\x7F/\\]/.test(name)) {
      throw new Error(
        "Unauthorized file name: Please do not use control characters, slash or anti-slash characters.",
      );
    }

    // I group both metadata and content write in the same IndexedDB
    // transaction (its mechanism for consistency) to avoid desynchronization.
    // There might still be due to a browser crash or power outage but shit
    // happens.
    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    const metadataStore = tx.objectStore(METADATA_STORE);
    const contentStore = tx.objectStore(CONTENT_STORE);
    const now = Date.now();
    const id = pathToId(path);
    metadataStore.put({
      id,
      fullPath: path,
      directory: getDirectory(path),
      name,
      type: "file",
      modified: now,
    });
    contentStore.put({ id, content });

    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();
    });
  }

  async readDir(dirPath) {
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";

    if (normalizedDirPath === "/") {
      return this._virtualRootDirs
        .map((d) => ({
          name: getName(d),
          type: "directory",
        }))
        .concat({
          name: "userdata",
          type: "directory",
        });
    }

    if (this._virtualRootDirs.includes(normalizedDirPath)) {
      if (normalizedDirPath === APPS_DIR) {
        return apps.map((a) => {
          return {
            name: `${a.id}.run`,
            icon: a.icon,
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
          };
        });
      }
      if (normalizedDirPath === SYSTEM_DIR) {
        return [
          {
            name: "desktop.config.json",
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
          },
          {
            name: "start_menu.config.json",
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
          },
        ];
      }
      throw new Error("Invalid directory: " + dirPath);
    }

    if (!normalizedDirPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Invalid directory: " + dirPath);
    }

    const db = await this._dbProm;
    const metadataStore = db
      .transaction(METADATA_STORE, "readonly")
      .objectStore(METADATA_STORE);

    const range = IDBKeyRange.only(normalizedDirPath);

    return new Promise((resolve, reject) => {
      const request = metadataStore.index("directory").getAll(range, 100);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (request.result.length === 0) {
          if (normalizedDirPath === USER_DATA_DIR) {
            resolve([]);
          } else {
            // For now we placed a system file in all other directories
            // If we don't see it, the directory doesn't exists
            reject(new Error("Invalid directory: " + dirPath));
          }
        }
        const res = [];
        for (const r of request.result) {
          if (r.name === DIR_CONFIG_FILENAME) {
            continue;
          }
          res.push({
            name: r.name,
            type: r.type,
            modified: r.modified,
          });
        }
        resolve(res);
      };
    });
  }

  async stat(filePath) {
    if (filePath.endsWith("/")) {
      throw new Error("Calling stat on a directory instead of a file");
    }
    if (filePath.startsWith(APPS_DIR)) {
      const id = filePath.substring(APPS_DIR.length, id.length - ".run".length);
      const app = apps.find((a) => a.id === id);
      if (!app || id.indexOf("/") >= 0) {
        throw new Error("Cannot stat file: file not found");
      }
      return {
        name: `${app.id}.run`,
        icon: app.icon,
        type: "file",
        modified: DEFAULT_MODIFIED_DATE,
      };
    }
    if (filePath.startsWith(SYSTEM_DIR)) {
      const file = filePath.substring(SYSTEM_DIR.length);
      if (["desktop.config.json", "start_menu.config.json"].includes(file)) {
        return {
          name: file,
          type: "file",
          modified: DEFAULT_MODIFIED_DATE,
        };
      }
    }

    if (!filePath.startsWith(USER_DATA_DIR)) {
      throw new Error("Cannot state file: file not found");
    }

    const db = await this._dbProm;
    const metadataStore = db
      .transaction(METADATA_STORE, "readonly")
      .objectStore(METADATA_STORE);

    const range = IDBKeyRange.only(filePath);

    return new Promise((resolve, reject) => {
      const request = metadataStore.index("directory").getAll(range, 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (request.result.length === 0) {
          throw new Error("Cannot state file: file not found");
        }
        resolve({
          name: request.result[0].name,
          type: request.result[0].type,
          modified: request.result[0].modified,
        });
      };
    });
  }

  async rmFile(filePath) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }
    if (path.endsWith("/")) {
      throw new Error("Writing a directory instead of a file");
    }

    // I group both metadata and content write in the same IndexedDB
    // transaction (its mechanism for consistency) to avoid desynchronization.
    // There might still be due to a browser crash or power outage but shit
    // happens.
    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();
      const id = pathToId(filePath);

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);
      metadataStore.delete(id);
      contentStore.delete(id);
    });
  }

  async mv(sourcePath, destinationPath) {
    if (!sourcePath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: The source directory is read-only");
    }
    if (!destinationPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const db = await this._dbProm;

    const allEntries = await this._readDirRecursive(sourcePath);
    return new Promise((resolve, reject) => {
      const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);

      allEntries.forEach((entry) => {
        const originalId = pathToId(entry.fullPath);
        let newPath;
        if (entry.fullPath === sourcePath) {
          newPath = destinationPath;
        } else {
          newPath = destinationPath + entry.fullPath.slice(sourcePath.length);
        }
        const newId = pathToId(newPath);
        metadataStore.put({
          ...dirEntry,
          id: newId,
          fullPath: newPath,
          directory: getDirectory(newPath),
          name: getName(newPath),
        });
        metadataStore.delete(originalId);

        if (entry.type !== "directory") {
          const getRequest = contentStore.get(originalId);
          getRequest.onsuccess = () => {
            if (getRequest.result) {
              contentStore.put({
                id: newId,
                content: getRequest.result.content,
              });
              contentStore.delete(originalId);
            }
          };
        }
      });
    });
  }

  async rm(path) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const db = await this._dbProm;

    const allEntries = await this._readDirRecursive(path);
    return new Promise((resolve, reject) => {
      const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);
      allEntries.forEach((entry) => {
        const originalId = pathToId(entry.fullPath);
        metadataStore.delete(originalId);

        if (entry.type !== "directory") {
          const getRequest = contentStore.get(originalId);
          getRequest.onsuccess = () => {
            if (getRequest.result) {
              contentStore.delete(originalId);
            }
          };
        }
      });
    });
  }

  /**
   * @param {string} path
   * @returns {Promise.<ArrayBuffer|string|Object>}
   */
  async readFile(path, format) {
    if (path.endsWith("/")) {
      throw new Error(
        "Calling `readFile` to read a directory. Use `readDir` instead.",
      );
    }

    if (path.startsWith(APPS_DIR)) {
      const wantedApp = path.substring(
        APPS_DIR.length,
        path.length - ".run".length,
      );
      for (const app of apps) {
        if (app.id === wantedApp) {
          return parseToWantedFormat(app, format);
        }
      }
      throw new Error("File not found: " + path);
    }

    if (path.startsWith(SYSTEM_DIR)) {
      const wantedFile = path.substring(SYSTEM_DIR.length);
      try {
        if (wantedFile === "desktop.config.json") {
          return parseToWantedFormat(
            {
              list: apps.map((app) => {
                return {
                  run: `/apps/${app.id}.run`,
                  title: app.title,
                  icon: app.icon,
                  desktopDir: app.desktopDir,
                };
              }),
            },
            format,
          );
        }
        if (wantedFile === "start_menu.config.json") {
          return parseToWantedFormat(
            {
              list: apps.map((app) => {
                return {
                  run: `/apps/${app.id}.run`,
                  title: app.title,
                  icon: app.icon,
                  inStartList: app.inStartList,
                };
              }),
            },
            format,
          );
        }
      } catch (err) {
        throw new Error("Impossible to read corrupted file: " + path);
      }
      throw new Error("File not found: " + path);
    }

    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("File not found: " + path);
    }

    const db = await this._dbProm;
    const contentStore = db
      .transaction(CONTENT_STORE, "readwrite")
      .objectStore(CONTENT_STORE);
    return new Promise((resolve, reject) => {
      const request = contentStore.get(pathToId(path));
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (!request.result) {
          reject(new Error("File not found."));
        }
        const content = request.result.content;
        try {
          resolve(parseToWantedFormat(content, format));
        } catch (err) {
          reject(err);
        }
      };
    });
  }

  async mkdir(path) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const db = await this._dbProm;
    const tx = db.transaction(METADATA_STORE, "readwrite");
    const store = tx.objectStore(METADATA_STORE);

    // TODO: What if the parent dir doesn't even exist?
    // Maybe add some consistency checks somewhere so it doesn't go out of hands

    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();

      const fullPath = path.endsWith("/") ? path : path + "/";
      const name = getName(fullPath);
      const now = Date.now();
      store.put({
        id: pathToId(fullPath),
        fullPath,
        directory: getDirectory(fullPath.substring(0, fullPath.length - 1)),
        name,
        type: "directory",
        modified: now,
      });

      const systemFile = fullPath + DIR_CONFIG_FILENAME;
      store.put({
        id: pathToId(systemFile),
        fullPath: systemFile,
        directory: fullPath,
        name: DIR_CONFIG_FILENAME,
        type: "system",
        modified: now,
      });
    });
  }
  async _readDirRecursive(dirPath) {
    const db = await this._dbProm;
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";

    return new Promise((resolve, reject) => {
      const transaction = db.transaction([METADATA_STORE], "readonly");
      const metadataStore = transaction.objectStore(METADATA_STORE);
      const allEntries = [];
      const request = metadataStore.openCursor();
      request.onerror = () => reject(request.error);
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const entry = cursor.value;

          // TODO: more efficient
          if (
            entry.fullPath === normalizedDirPath ||
            entry.fullPath.startsWith(normalizedDirPath)
          ) {
            allEntries.push(entry);
          }
          cursor.continue();
        } else {
          resolve(allEntries);
        }
      };
    });
  }
}

const fs = new DesktopFileSystem();
export default fs;
window.fs = fs;

function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      const store = db.createObjectStore(METADATA_STORE, { keyPath: "id" });
      store.createIndex("directory", "directory");
      store.createIndex("fullPath", "fullPath", { unique: true });

      // Store content separately for efficiency
      db.createObjectStore(CONTENT_STORE, { keyPath: "id" });
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function getDirectory(path) {
  return path.substring(0, path.lastIndexOf("/") + 1);
}

function getName(path) {
  return path.split("/").filter(Boolean).pop();
}

function pathToId(path) {
  const utf8Bytes = new TextEncoder().encode(path);
  return btoa(String.fromCharCode(...utf8Bytes))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

// function idToPath(id) {
//   id = id.replace(/-/g, "+").replace(/_/g, "/");
//   const bytes = Uint8Array.from(atob(id), (c) => c.charCodeAt(0));
//   return new TextDecoder().decode(bytes);
// }

function parseToWantedFormat(data, format) {
  if (format === "arraybuffer") {
    if (typeof data === "string") {
      return textEncoder.encode(data);
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return textEncoder.encode(JSON.stringify(data));
    } else {
      throw new Error(
        "Impossible to parse to ArrayBuffer the following file: " + path,
      );
    }
  }

  if (format === "object") {
    if (typeof data === "string") {
      return JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      throw new Error(
        "Impossible to parse to Object the following file: " + path,
      );
    } else if (typeof data === "object") {
      return data;
    } else {
      throw new Error(
        "Impossible to parse to Object the following file: " + path,
      );
    }
  }

  // else this is a string that is wanted
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return textDecoder.decode(data);
  }
  return JSON.stringify(data);
}
