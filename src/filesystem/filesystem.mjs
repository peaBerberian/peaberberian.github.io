// TODO: Make base mostly work even without `IndexedDB` API (just do not store
// long term in that case)

// TODO: For now I chose that all operations maintain a lock until finished to
// prevent some weird states when there's multiple transactions involved.
// However, IndexedDB has such a mechanism built-in called "transactions". I
// could rely on this instead.

// /!\ Apps file is automatically generated by the build script
import apps from "../__generated_apps.mjs";

import FileSystemError from "./error.mjs";
import checkAndRepairIntegrity from "./filesystem_check.mjs";
import {
  METADATA_STORE,
  CONTENT_STORE,
  APPS_DIR,
  SYSTEM_DIR,
  USER_DATA_DIR,
  USER_CONFIG_DIR,
  DESKTOP_CONFIG,
  START_MENU_CONFIG,
  PROVIDERS_CONFIG,
  DEFAULT_APPS_CONFIG,
  DIR_CONFIG_FILENAME,
  RESERVED_NAMES,
  DEFAULT_MODIFIED_DATE,
  openDB,
  getDirPath,
  getName,
  pathToId,
  parseToWantedFormat,
  generateDesktopConfig,
  generateStartMenuConfig,
  generateProvidersConfig,
  generateDefaultAppsConfig,
  checkWrittenFilePath,
  formatWrittenFileContent,
  pathJoin,
  getContainingDirectory,
  isEntryPath,
} from "./utils.mjs";

export { getName, getDirPath, pathJoin };

class DesktopFileSystem {
  constructor() {
    this._apps = apps;
    this._watchedPaths = new Map();
    const setUpDb = () => {
      this._dbProm = openDB().then(async (db) => {
        await checkAndRepairIntegrity(db);
        db.addEventListener("close", () => {
          // TODO: If I wasn't lazy, I would have done that sweet exponential
          // backoff stuff.
          // But with ifs, I cut wood (...that expression doesn't seem to make
          // any sense when written in english)
          setTimeout(setUpDb, 2000);
        });
        return db;
      });
    };
    setUpDb();
    this._virtualRootDirs = [APPS_DIR, SYSTEM_DIR];
    this._queue = [];
  }

  /**
   * NOTE: If watching a directory, the callback will trigger only if its
   * content changes or if the directory itself is added/removed/overwritten.
   *
   * @param {string} path
   * @param {Function} cb
   * @param {AbortSignal} abortSignal
   */
  watch(path, cb, abortSignal) {
    if (abortSignal.aborted) {
      return;
    }
    const cbList = this._watchedPaths.get(path);
    if (!cbList) {
      const cbList = [cb];
      this._watchedPaths.set(path, cbList);
    } else {
      cbList.push(cb);
      this._watchedPaths.set(path, cbList);
    }
    abortSignal.addEventListener("abort", () => {
      const cbList = this._watchedPaths.get(path);
      for (let i = cbList.length - 1; i >= 0; i--) {
        if (cbList[i] === cb) {
          cbList.splice(i, 1);
        }
      }
    });
  }

  async writeFile(path, content) {
    checkWrittenFilePath(path);
    const contentAb = formatWrittenFileContent(content);
    return this._scheduleLockingOperation(() =>
      this._writeFileUnchecked(path, contentAb).then(() =>
        this._triggerWatchers([path]),
      ),
    );
  }

  async readDir(dirPath) {
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";
    return this._scheduleLockingOperation(async () => {
      const dirContent = await this._readDirEntries(normalizedDirPath);
      return dirContent.map((d) => {
        return {
          name: d.name,
          type: d.type,
          icon: d.icon,
          modified: d.modified,
          size: d.size,
        };
      });
    });
  }

  async stat(filePath) {
    if (filePath.endsWith("/")) {
      throw new FileSystemError(
        "WrongTypeError",
        "Calling stat on a directory instead of a file",
      );
    }

    return this._scheduleLockingOperation(async () => {
      // For now just read the whole dir and do not burn too much neurons. We'll
      // see if we improve that in the future.
      const directory = getDirPath(filePath);
      const dirContent = await this._readDirEntries(directory);
      const result = dirContent.find((x) => isEntryPath(x, filePath));
      if (!result) {
        throw new FileSystemError("NoEntryError", "File not found");
      }
      return {
        name: result.name,
        type: result.type,
        icon: result.icon,
        modified: result.modified,
        size: result.size,
      };
    });
  }

  async rmFile(filePath) {
    checkWrittenFilePath(filePath);
    return this._scheduleLockingOperation(async () =>
      this._rmFileUnchecked(filePath).then(() => {
        this._triggerWatchers([filePath]);
      }),
    );
  }

  // NOTE: It looks complex because it is badly done, I don't know why I
  // particularly failed to do a simple thing on this one
  async mv(srcPath, baseDestPath) {
    let normalizedDest;

    if (!canPathBeUpdated(srcPath)) {
      throw new FileSystemError(
        "PermissionError",
        "The source directory is read-only",
      );
    }

    if (srcPath.endsWith("/")) {
      // Moving a Directory
      // TODO: Did I actually check that this is a directory and the rest isn't?
      normalizedDest = baseDestPath.endsWith("/")
        ? baseDestPath
        : baseDestPath + "/";
      if (normalizedDest.startsWith(srcPath)) {
        if (normalizedDest === srcPath) {
          return;
        }
        throw new FileSystemError(
          "IllegalOperation",
          "Cannot move directory: moving inside itself",
        );
      }
      if (!canPathBeUpdated(normalizedDest)) {
        throw new FileSystemError(
          "PermissionError",
          "The destination directory is read-only",
        );
      }
    } else {
      // Moving a file
      normalizedDest = baseDestPath.endsWith("/")
        ? baseDestPath + getName(srcPath)
        : baseDestPath;
      if (!canPathBeWrittenIn(normalizedDest)) {
        throw new FileSystemError(
          "PermissionError",
          "The destination directory is read-only",
        );
      }
    }

    const segmentedSrcPath = srcPath.split("/");
    for (const segment of segmentedSrcPath) {
      if (RESERVED_NAMES.includes(segment)) {
        throw new FileSystemError(
          "PermissionError",
          "Tried to move a system file",
        );
      }
    }

    const segmentedDestPath = normalizedDest.split("/");
    for (let segmentI = 0; segmentI < segmentedDestPath.length; segmentI++) {
      const segment = segmentedDestPath[segmentI];
      if (segment === "") {
        if (segmentI === 0) {
          continue; // leading slash
        } else if (segmentI === segmentedDestPath.length - 1) {
          continue; // ending slash
        } else {
          throw new FileSystemError("InvalidOperation", "Invalid path");
        }
      }
      if (RESERVED_NAMES.includes(segment)) {
        throw new FileSystemError(
          "IllegalOperation",
          "Destination path contains a reserved name",
        );
      }
      if (/[\x00-\x1F\x7F/\\]/.test(segment)) {
        throw new FileSystemError(
          "InvalidOperation",
          "Unauthorized file name: Please do not use control characters, slash or anti-slash characters.",
        );
      }
    }

    const updatedNormalizedPaths = [];
    return this._scheduleLockingOperation(async () => {
      let allEntries;
      if (srcPath.endsWith("/")) {
        const destEntries = await this._readDirEntries(
          getDirPath(normalizedDest.substring(0, normalizedDest.length - 1)),
        );
        if (destEntries.some((entry) => isEntryPath(entry, normalizedDest))) {
          throw new FileSystemError(
            "IllegalOperation",
            "Cannot move directory: destination path already exists",
          );
        }
        allEntries = await this._readDirRecursive(srcPath);
      } else {
        // NOTE: As the entry keys is just the encoded path, I don't think we
        // could have dangling content due to a move? So do not remove first.
        const dirContent = await this._readDirEntries(
          getContainingDirectory(srcPath),
        );
        const result = dirContent.find((x) => isEntryPath(x, srcPath));
        if (!result) {
          throw new FileSystemError(
            "NoEntryError",
            "Cannot move file: file not found.",
          );
        }

        allEntries = [result];
      }

      const db = await this._dbProm;
      await new Promise((resolve, reject) => {
        const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
        tx.onerror = () =>
          reject(
            new FileSystemError(
              "TransactionError",
              tx?.error?.toString?.() ?? "Unknown transaction error",
            ),
          );
        tx.oncomplete = () => resolve();

        const metadataStore = tx.objectStore(METADATA_STORE);
        const contentStore = tx.objectStore(CONTENT_STORE);

        if (allEntries.length === 0) {
          throw new FileSystemError(
            "NoEntryError",
            'Cannot move file: Source path: "' +
              String(srcPath) +
              '" not found',
          );
        }

        allEntries.forEach((entry) => {
          const originalId = entry.id;
          let newFullPath;
          if (isEntryPath(entry, srcPath)) {
            newFullPath = normalizedDest.endsWith("/")
              ? normalizedDest.substring(0, normalizedDest.length - 1)
              : normalizedDest;
          } else {
            // Else, we're in a directory case where `normalizedDest` is the
            // destination directory.
            // Replace `srcPath` with it.
            newFullPath = pathJoin(
              normalizedDest,
              entry.fullPath.slice(srcPath.length),
            );
          }

          const normalizedNewPath =
            entry.type === "directory" ? newFullPath + "/" : newFullPath;
          if (isEntryPath(entry, normalizedNewPath)) {
            return;
          }

          const newDir = getContainingDirectory(newFullPath);
          const newId = pathToId(newFullPath);

          if (entry.type !== "system") {
            updatedNormalizedPaths.push(
              entry.type === "directory"
                ? entry.fullPath + "/"
                : entry.fullPath,
            );
            updatedNormalizedPaths.push(normalizedNewPath);
          }
          metadataStore.put({
            ...entry,
            id: newId,
            fullPath: newFullPath,
            directory: newDir,
            name: getName(newFullPath),
          });
          metadataStore.delete(originalId);

          if (entry.type === "file") {
            const getRequest = contentStore.get(originalId);
            getRequest.onsuccess = () => {
              if (getRequest.result) {
                contentStore.put({
                  id: newId,
                  content: getRequest.result.content,
                });
                contentStore.delete(originalId);
              }
            };
          }
        });
      });
    }).then(() => {
      this._triggerWatchers(updatedNormalizedPaths);
    });
  }

  async rmDir(path) {
    const normalizedPath = path.endsWith("/") ? path : path + "/";
    if (!canPathBeUpdated(normalizedPath)) {
      throw new FileSystemError(
        "PermissionError",
        "This directory is read-only",
      );
    }

    const updatedNormalizedPaths = [];
    return this._scheduleLockingOperation(async () => {
      const db = await this._dbProm;

      const allEntries = await this._readDirRecursive(normalizedPath);
      return new Promise((resolve, reject) => {
        const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
        tx.onerror = () =>
          reject(
            new FileSystemError(
              "TransactionError",
              tx?.error?.toString?.() ?? "Unknown transaction error",
            ),
          );
        tx.oncomplete = () => resolve();

        const metadataStore = tx.objectStore(METADATA_STORE);
        const contentStore = tx.objectStore(CONTENT_STORE);
        allEntries.forEach((entry) => {
          const originalId = pathToId(entry.fullPath);
          if (entry.type !== "system") {
            updatedNormalizedPaths.push(
              entry.type === "directory"
                ? entry.fullPath + "/"
                : entry.fullPath,
            );
          }
          metadataStore.delete(originalId);

          if (entry.type !== "directory") {
            const getRequest = contentStore.get(originalId);
            getRequest.onsuccess = () => {
              if (getRequest.result) {
                contentStore.delete(originalId);
              }
            };
          }
        });
      });
    }).then(() => {
      this._triggerWatchers(updatedNormalizedPaths);
    });
  }

  /**
   * @param {string} path
   * @returns {Promise.<ArrayBuffer|string|Object>}
   */
  async readFile(path, format) {
    if (path.endsWith("/")) {
      throw new FileSystemError(
        "WrongTypeError",
        "Calling `readFile` to read a directory. Use `readDir` instead.",
      );
    }

    if (path.startsWith(APPS_DIR)) {
      const wantedApp = path.substring(
        APPS_DIR.length,
        path.length - ".run".length,
      );

      // As this should be relatively frequent, we may also do a map
      // though at current scale, don't think it will have real-life impact
      for (const app of this._apps) {
        if (app.id === wantedApp) {
          return parseToWantedFormat(app, format);
        }
      }
      throw new FileSystemError("NoEntryError", "File not found: " + path);
    }

    if (path.startsWith(SYSTEM_DIR)) {
      const wantedFile = path.substring(SYSTEM_DIR.length);
      try {
        if (wantedFile === DESKTOP_CONFIG) {
          const desktopConfig = generateDesktopConfig();
          return parseToWantedFormat(desktopConfig, format);
        }
        if (wantedFile === START_MENU_CONFIG) {
          const startMenuConfig = generateStartMenuConfig();
          return parseToWantedFormat(startMenuConfig, format);
        }
        if (wantedFile === PROVIDERS_CONFIG) {
          const providersConfig = generateProvidersConfig();
          return parseToWantedFormat(providersConfig, format);
        }
        if (wantedFile === DEFAULT_APPS_CONFIG) {
          const defaultAppsConfig = generateDefaultAppsConfig();
          return parseToWantedFormat(defaultAppsConfig, format);
        }
      } catch (err) {
        throw new FileSystemError(
          "ParsingError",
          "Impossible to read corrupted file: " + path,
        );
      }
      throw new FileSystemError("NoEntryError", "File not found: " + path);
    }

    if (!canPathBeWrittenIn(path)) {
      throw new FileSystemError("NoEntryError", "File not found: " + path);
    }

    return this._scheduleLockingOperation(async () => {
      const db = await this._dbProm;
      const contentStore = db
        .transaction(CONTENT_STORE, "readwrite")
        .objectStore(CONTENT_STORE);
      return new Promise((resolve, reject) => {
        const request = contentStore.get(pathToId(path));
        request.onerror = () =>
          reject(
            new FileSystemError(
              "TransactionError",
              request?.error?.toString?.() ?? "Unknown transaction error",
            ),
          );
        request.onsuccess = () => {
          if (!request.result) {
            reject(new FileSystemError("NoEntryError", "File not found."));
          }
          const content = request.result.content;
          try {
            resolve(parseToWantedFormat(content, format));
          } catch (err) {
            const formattedErr = new FileSystemError(
              "ParsingError",
              "Impossible to read corrupted file: " +
                (err?.toString?.() ?? "Unknown Error"),
            );
            reject(formattedErr);
          }
        };
      });
    });
  }

  async mkdir(path) {
    const normalizedPath = path.endsWith("/") ? path : path + "/";
    if (!canPathBeWrittenIn(normalizedPath)) {
      throw new FileSystemError(
        "PermissionError",
        "This directory is read-only",
      );
    }

    const name = getName(normalizedPath);
    const parentDir = getContainingDirectory(normalizedPath);

    if (RESERVED_NAMES.includes(name)) {
      throw new FileSystemError(
        "IllegalOperation",
        "Using a reserved system name",
      );
    }

    if (/[\x00-\x1F\x7F/\\]/.test(name) || name === "") {
      throw new FileSystemError(
        "InvalidOperation",
        "Unauthorized directory name: Please do not use control characters, slash or anti-slash characters.",
      );
    }

    return this._scheduleLockingOperation(async () => {
      const list = await this._readDirEntries(parentDir);
      for (const entry of list) {
        if (entry.name === name) {
          throw new FileSystemError(
            "IllegalOperation",
            "An item with that name already exists in this directory.",
          );
        }
      }

      const db = await this._dbProm;
      const tx = db.transaction(METADATA_STORE, "readwrite");
      const store = tx.objectStore(METADATA_STORE);
      return new Promise((resolve, reject) => {
        tx.onerror = () =>
          reject(
            new FileSystemError(
              "TransactionError",
              tx?.error?.toString?.() ?? "Unknown transaction error",
            ),
          );
        tx.oncomplete = () => resolve();

        const fullPath = normalizedPath.substring(0, normalizedPath.length - 1);
        const now = Date.now();
        store.put({
          id: pathToId(fullPath),
          fullPath,
          directory: parentDir,
          name,
          type: "directory",
          modified: now,
          size: 0,
        });

        // Simple fake file for now to always have at least one file in dirs
        // TODO: Remove the need for this
        const systemFile = normalizedPath + DIR_CONFIG_FILENAME;
        store.put({
          id: pathToId(systemFile),
          fullPath: systemFile,
          directory: normalizedPath,
          name: DIR_CONFIG_FILENAME,
          type: "system",
          modified: now,
          size: 0,
        });
      }).then(() => {
        this._triggerWatchers([normalizedPath]);
      });
    });
  }

  _scheduleLockingOperation(operationCb) {
    return new Promise((resolve, reject) => {
      const shouldRestartQueue = this._queue.length === 0;
      const queueItem = { resolve, reject, operationCb };
      this._queue.push(queueItem);
      if (shouldRestartQueue) {
        this._performNextOperation();
      }
    });
  }

  _performNextOperation() {
    const nextOp = this._queue[0];
    if (!nextOp) {
      return;
    }
    nextOp.operationCb().then(
      (res) => {
        if (this._queue[0] === nextOp) {
          this._queue.shift();
        }
        nextOp.resolve(res);
        this._performNextOperation();
      },
      (err) => {
        if (this._queue[0] === nextOp) {
          this._queue.shift();
        }
        const formattedErr =
          err instanceof FileSystemError
            ? err
            : new FileSystemError(
                "IDBError",
                err?.toString?.() ?? "Unknown Error",
              );
        nextOp.reject(formattedErr);
        this._performNextOperation();
      },
    );
  }

  async _readDirEntries(dirPath) {
    if (!dirPath.endsWith("/")) {
      throw new FileSystemError(
        "WrongTypeError",
        "Calling stat on a directory instead of a file",
      );
    }
    if (dirPath === "/") {
      const userDataFullPath = USER_DATA_DIR.substring(
        0,
        USER_DATA_DIR.length - 1,
      );
      const userConfigFullPath = USER_CONFIG_DIR.substring(
        0,
        USER_CONFIG_DIR.length - 1,
      );
      return this._virtualRootDirs
        .map((d) => {
          const fullPath = d.substring(0, d.length - 1);
          return {
            id: pathToId(fullPath),
            fullPath,
            directory: "/",
            name: getName(fullPath),
            type: "directory",
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          };
        })
        .concat(
          {
            id: pathToId(userDataFullPath),
            fullPath: userDataFullPath,
            directory: "/",
            name: getName(userDataFullPath),
            type: "directory",
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          },
          {
            id: pathToId(userConfigFullPath),
            fullPath: userConfigFullPath,
            directory: "/",
            name: getName(userConfigFullPath),
            type: "directory",
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          },
        );
    }
    if (this._virtualRootDirs.includes(dirPath)) {
      if (dirPath === APPS_DIR) {
        return this._apps.map((app) => {
          const name = `${app.id}.run`;
          const fullPath = APPS_DIR + name;
          return {
            id: pathToId(fullPath),
            fullPath,
            directory: APPS_DIR,
            name,
            type: "file",
            icon: app.icon,
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          };
        });
      }
      if (dirPath === SYSTEM_DIR) {
        return [
          DESKTOP_CONFIG,
          START_MENU_CONFIG,
          PROVIDERS_CONFIG,
          DEFAULT_APPS_CONFIG,
        ].map((filename) => {
          const fullPath = SYSTEM_DIR + filename;
          return {
            id: pathToId(fullPath),
            fullPath,
            directory: SYSTEM_DIR,
            name: filename,
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          };
        });
      }
      throw new FileSystemError(
        "NoEntryError",
        "Invalid directory: " + dirPath,
      );
    }

    if (!canPathBeWrittenIn(dirPath)) {
      throw new FileSystemError(
        "NoEntryError",
        "Invalid directory: " + dirPath,
      );
    }

    const db = await this._dbProm;
    const metadataStore = db
      .transaction(METADATA_STORE, "readonly")
      .objectStore(METADATA_STORE);

    const range = IDBKeyRange.only(dirPath);

    return new Promise((resolve, reject) => {
      const request = metadataStore.index("directory").getAll(range, 100);
      request.onerror = () =>
        reject(
          new FileSystemError(
            "TransactionError",
            request?.error?.toString?.() ?? "Unknown transaction error",
          ),
        );
      request.onsuccess = () => {
        if (request.result.length === 0) {
          if ([USER_DATA_DIR, USER_CONFIG_DIR].includes(dirPath)) {
            resolve([]);
          } else {
            // For now we placed a system file in all other directories
            // If we don't see it, the directory doesn't exists
            reject(
              new FileSystemError(
                "NoEntryError",
                "Invalid directory: " + dirPath,
              ),
            );
          }
          return;
        }
        resolve(request.result.filter((r) => r.name !== DIR_CONFIG_FILENAME));
      };
    });
  }

  async _readDirRecursive(dirPath) {
    const db = await this._dbProm;
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";

    return new Promise((resolve, reject) => {
      const transaction = db.transaction([METADATA_STORE], "readonly");
      const metadataStore = transaction.objectStore(METADATA_STORE);
      const allEntries = [];
      const request = metadataStore.openCursor();
      request.onerror = () =>
        reject(
          new FileSystemError(
            "TransactionError",
            request?.error?.toString?.() ?? "Unknown transaction error",
          ),
        );
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const entry = cursor.value;
          if (
            isEntryPath(entry, normalizedDirPath) ||
            entry.fullPath.startsWith(normalizedDirPath)
          ) {
            allEntries.push(entry);
          }
          cursor.continue();
        } else {
          resolve(allEntries);
        }
      };
    });
  }

  async _writeFileUnchecked(path, contentAb) {
    const name = getName(path);
    const directoryPath = getDirPath(path);

    // Delete first previous file if one
    const list = await this._readDirEntries(directoryPath);
    for (const entry of list) {
      if (entry.name === name) {
        await this._rmFileUnchecked(directoryPath + entry.name);
      }
    }

    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    const metadataStore = tx.objectStore(METADATA_STORE);
    const contentStore = tx.objectStore(CONTENT_STORE);
    const now = Date.now();
    const id = pathToId(path);
    metadataStore.put({
      id,
      fullPath: path,
      directory: directoryPath,
      name,
      size: contentAb.byteLength,
      type: "file",
      modified: now,
    });
    contentStore.put({ id, content: contentAb });

    return new Promise((resolve, reject) => {
      tx.onerror = () =>
        reject(
          new FileSystemError(
            "TransactionError",
            tx?.error?.toString?.() ?? "Unknown transaction error",
          ),
        );
      tx.oncomplete = () => resolve();
    });
  }

  async _rmFileUnchecked(filePath) {
    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    return new Promise((resolve, reject) => {
      tx.onerror = () =>
        reject(
          new FileSystemError(
            "TransactionError",
            tx?.error?.toString?.() ?? "Unknown transaction error",
          ),
        );
      tx.oncomplete = () => resolve();
      const id = pathToId(filePath);

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);
      metadataStore.delete(id);
      contentStore.delete(id);
    });
  }

  _triggerWatchers(updatedPaths) {
    const paths = new Set();
    updatedPaths.forEach((p) => {
      paths.add(p);
      paths.add(getContainingDirectory(p));
    });
    for (const path of paths) {
      const watchers = this._watchedPaths.get(path);
      if (watchers) {
        watchers.slice().forEach((cb) => {
          cb({});
        });
      }
    }

    // NOTE: I made it initially fully-recursive but I'm not sure that some
    // code watching e.g. `/`  would like to hear about deeply nested-dirs.
    // So not it's only a direct relation
    // if (path === "/") {
    //   return;
    // }
    // const parentDir = getContainingDirectory(path);
    // return this._triggerWatchers(parentDir, arg);
  }
}

const fs = new DesktopFileSystem();
export default fs;

function canPathBeWrittenIn(path) {
  return [USER_DATA_DIR, USER_CONFIG_DIR].some((dir) => path.startsWith(dir));
}

function canPathBeUpdated(path) {
  return [USER_DATA_DIR, USER_CONFIG_DIR].some(
    (dir) => path.startsWith(dir) && path !== dir,
  );
}
