// TODO: Make base mostly work even without `IndexedDB` API (just do not store
// long term in that case)
// TODO: Consistency check
// TODO: Special Error objects?

// TODO: For now I chose that all operations maintain a lock until finished to
// TODO: Re-create closed database
// prevent some weird states when there's multiple transactions involved.
// However, IndexedDB has such a mechanism built-in called "transactions". I
// could rely on this instead.

// /!\ Apps file is automatically generated by the build script
import apps from "../__generated_apps.mjs";

const DB_NAME = "local_fs";
const DB_VERSION = 1;

const METADATA_STORE = "files";
const CONTENT_STORE = "files_content";

const APPS_DIR = "/apps/";
const SYSTEM_DIR = "/system/";
const USER_DATA_DIR = "/userdata/";

const DESKTOP_CONFIG = "desktop.config.json";
const START_MENU_CONFIG = "start_menu.config.json";
const PROVIDERS_CONFIG = "providers.config.json";
const DEFAULT_APPS_CONFIG = "default_apps.config.json";

const DIR_CONFIG_FILENAME = ".dir_config";

const RESERVED_NAMES = [DIR_CONFIG_FILENAME, ".", ".."];

const DEFAULT_MODIFIED_DATE = 1747073021004;

const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();

class DesktopFileSystem {
  constructor() {
    this._apps = apps;
    this._dbProm = openDB();
    this._virtualRootDirs = [APPS_DIR, SYSTEM_DIR];
    this._queue = [];
  }

  async writeFile(path, content) {
    checkWrittenFilePath(path);
    const contentAb = formatWrittenFileContent(content);
    return this._scheduleLockingOperation(() =>
      this._writeFileUnchecked(path, contentAb),
    );
  }

  async readDir(dirPath) {
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";
    return this._scheduleLockingOperation(async () => {
      const dirContent = await this._readDirEntries(normalizedDirPath);
      return dirContent.map((d) => {
        return {
          name: d.name,
          type: d.type,
          icon: d.icon,
          modified: d.modified,
          size: d.size,
        };
      });
    });
  }

  async stat(filePath) {
    if (filePath.endsWith("/")) {
      throw new Error("Calling stat on a directory instead of a file");
    }

    return this._scheduleLockingOperation(async () => {
      // For now just read the whole dir and do not burn too much neurons. We'll
      // see if we improve that in the future.
      const directory = getDirPath(filePath);
      const dirContent = await this._readDirEntries(directory);
      const result = dirContent.find((x) => x.fullPath === filePath);
      if (!result) {
        throw new Error("File not found");
      }
      return {
        name: result.name,
        type: result.type,
        icon: result.icon,
        modified: result.modified,
        size: result.size,
      };
    });
  }

  async rmFile(filePath) {
    checkWrittenFilePath(filePath);
    return this._scheduleLockingOperation(async () =>
      this._rmFileUnchecked(filePath),
    );
  }

  // NOTE: It looks complex because it is badly done, I don't know why I
  // particularly failed to do a simple thing on this one
  async mv(srcPath, baseDestPath) {
    if (!srcPath.startsWith(USER_DATA_DIR) || srcPath === USER_DATA_DIR) {
      throw new Error("Permission denied: The source directory is read-only");
    }
    if (!baseDestPath.startsWith(USER_DATA_DIR)) {
      throw new Error(
        "Permission denied: The destination directory is read-only",
      );
    }

    const segmentedSrcPath = srcPath.split("/");
    for (const segment of segmentedSrcPath) {
      if (RESERVED_NAMES.includes(segment)) {
        throw new Error("Permission denied: Tried to move a system file");
      }
    }

    const segmentedDestPath = baseDestPath.split("/");
    for (let segmentI = 0; segmentI < segmentedDestPath.length; segmentI++) {
      const segment = segmentedDestPath[segmentI];
      if (segment === "") {
        if (segmentI === 0) {
          continue; // leading slash
        } else if (segmentI === segmentedDestPath.length - 1) {
          continue; // ending slash
        } else {
          throw new Error("Permission denied: Invalid path");
        }
      }
      if (RESERVED_NAMES.includes(segment)) {
        throw new Error(
          "Permission denied: Destination path contains a reserved name",
        );
      }
      if (/[\x00-\x1F\x7F/\\]/.test(segment)) {
        throw new Error(
          "Unauthorized file name: Please do not use control characters, slash or anti-slash characters.",
        );
      }
    }

    return this._scheduleLockingOperation(async () => {
      let allEntries;

      let normalizedDest;
      if (srcPath.endsWith("/")) {
        // Moving a Directory
        normalizedDest = baseDestPath.endsWith("/")
          ? baseDestPath
          : baseDestPath + "/";
        if (normalizedDest.startsWith(srcPath)) {
          throw new Error("Cannot move directory: moving inside itself");
        }
        if (normalizedDest === USER_DATA_DIR) {
          throw new Error(
            "Permission denied: The destination directory is read-only",
          );
        }

        const destEntries = await this._readDirEntries(
          getDirPath(normalizedDest.substring(0, normalizedDest.length - 1)),
        );
        if (destEntries.some((e) => e.fullPath === normalizedDest)) {
          throw new Error(
            "Cannot move directory: destination path already exists",
          );
        }
        allEntries = await this._readDirRecursive(srcPath);
      } else {
        // Moving a file
        normalizedDest = baseDestPath.endsWith("/")
          ? baseDestPath + getName(srcPath)
          : baseDestPath;

        // NOTE: As the entry keys is just the encoded path, I don't think we
        // could have dangling content due to a move?
        // const destEntries = await this._readDirEntries(
        //   getDirPath(normalizedDest),
        // );
        //
        // if (destEntries.some((e) => e.fullPath === normalizedDest)) {
        //   try {
        //     await fs.rmFile(normalizedDest);
        //   } catch (err) {
        //     throw new Error(
        //       "Cannot move file: destination path already exists and failed to remove it.",
        //     );
        //   }
        // }

        const dirContent = await this._readDirEntries(
          getContainingDirectory(srcPath),
        );
        const result = dirContent.find((x) => x.fullPath === srcPath);
        if (!result) {
          throw new Error("Cannot move file: file not found.");
        }

        allEntries = [result];
      }

      const db = await this._dbProm;
      return new Promise((resolve, reject) => {
        const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
        tx.onerror = () => reject(tx.error);
        tx.oncomplete = () => resolve();

        const metadataStore = tx.objectStore(METADATA_STORE);
        const contentStore = tx.objectStore(CONTENT_STORE);

        if (allEntries.length === 0) {
          throw new Error(
            'Cannot move file: Source path: "' +
              String(srcPath) +
              '" not found',
          );
        }

        allEntries.forEach((entry) => {
          const originalId = entry.id;
          let newPath;
          if (entry.fullPath === srcPath) {
            newPath = normalizedDest;
          } else {
            // Else, we're in a directory case where `normalizedDest` is the
            // destination directory.
            // Replace `srcPath` with it.
            newPath = pathJoin(
              normalizedDest,
              entry.fullPath.slice(srcPath.length),
            );
          }

          if (entry.fullPath === newPath) {
            return;
          }

          const newDir = getContainingDirectory(newPath);

          const newId = pathToId(newPath);
          metadataStore.put({
            ...entry,
            id: newId,
            fullPath: newPath,
            directory: newDir,
            name: getName(newPath),
          });
          metadataStore.delete(originalId);

          if (entry.type === "file") {
            const getRequest = contentStore.get(originalId);
            getRequest.onsuccess = () => {
              if (getRequest.result) {
                contentStore.put({
                  id: newId,
                  content: getRequest.result.content,
                });
                contentStore.delete(originalId);
              }
            };
          }
        });
      });
    });
  }

  async rmDir(path) {
    const fullPath = path.endsWith("/") ? path : path + "/";
    if (!fullPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    return this._scheduleLockingOperation(async () => {
      const db = await this._dbProm;

      const allEntries = await this._readDirRecursive(fullPath);
      return new Promise((resolve, reject) => {
        const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
        tx.onerror = () => reject(tx.error);
        tx.oncomplete = () => resolve();

        const metadataStore = tx.objectStore(METADATA_STORE);
        const contentStore = tx.objectStore(CONTENT_STORE);
        allEntries.forEach((entry) => {
          const originalId = pathToId(entry.fullPath);
          metadataStore.delete(originalId);

          if (entry.type !== "directory") {
            const getRequest = contentStore.get(originalId);
            getRequest.onsuccess = () => {
              if (getRequest.result) {
                contentStore.delete(originalId);
              }
            };
          }
        });
      });
    });
  }

  /**
   * @param {string} path
   * @returns {Promise.<ArrayBuffer|string|Object>}
   */
  async readFile(path, format) {
    if (path.endsWith("/")) {
      throw new Error(
        "Calling `readFile` to read a directory. Use `readDir` instead.",
      );
    }

    if (path.startsWith(APPS_DIR)) {
      const wantedApp = path.substring(
        APPS_DIR.length,
        path.length - ".run".length,
      );

      // As this should be relatively frequent, we may also do a map
      // though at current scale, don't think it will have real-life impact
      for (const app of this._apps) {
        if (app.id === wantedApp) {
          return parseToWantedFormat(app, format);
        }
      }
      throw new Error("File not found: " + path);
    }

    if (path.startsWith(SYSTEM_DIR)) {
      const wantedFile = path.substring(SYSTEM_DIR.length);
      try {
        if (wantedFile === DESKTOP_CONFIG) {
          const desktopConfig = generateDesktopConfig();
          return parseToWantedFormat(desktopConfig, format);
        }
        if (wantedFile === START_MENU_CONFIG) {
          const startMenuConfig = generateStartMenuConfig();
          return parseToWantedFormat(startMenuConfig, format);
        }
        if (wantedFile === PROVIDERS_CONFIG) {
          const providersConfig = generateProvidersConfig();
          return parseToWantedFormat(providersConfig, format);
        }
        if (wantedFile === DEFAULT_APPS_CONFIG) {
          const defaultAppsConfig = generateDefaultAppsConfig();
          return parseToWantedFormat(defaultAppsConfig, format);
        }
      } catch (err) {
        throw new Error("Impossible to read corrupted file: " + path);
      }
      throw new Error("File not found: " + path);
    }

    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("File not found: " + path);
    }

    return this._scheduleLockingOperation(async () => {
      const db = await this._dbProm;
      const contentStore = db
        .transaction(CONTENT_STORE, "readwrite")
        .objectStore(CONTENT_STORE);
      return new Promise((resolve, reject) => {
        const request = contentStore.get(pathToId(path));
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          if (!request.result) {
            reject(new Error("File not found."));
          }
          const content = request.result.content;
          try {
            resolve(parseToWantedFormat(content, format));
          } catch (err) {
            reject(err);
          }
        };
      });
    });
  }

  async mkdir(path) {
    const fullPath = path.endsWith("/") ? path : path + "/";
    if (!fullPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const name = getName(fullPath);
    const parentDir = getDirPath(fullPath.substring(0, fullPath.length - 1));

    if (RESERVED_NAMES.includes(name)) {
      throw new Error("Using a reserved system name");
    }

    if (/[\x00-\x1F\x7F/\\]/.test(name) || name === "") {
      throw new Error(
        "Unauthorized directory name: Please do not use control characters, slash or anti-slash characters.",
      );
    }

    return this._scheduleLockingOperation(async () => {
      const list = await this._readDirEntries(parentDir);
      for (const entry of list) {
        if (entry.name === name) {
          throw new Error(
            "An item with that name already exists in this directory.",
          );
        }
      }

      const db = await this._dbProm;
      const tx = db.transaction(METADATA_STORE, "readwrite");
      const store = tx.objectStore(METADATA_STORE);
      return new Promise((resolve, reject) => {
        tx.onerror = () => reject(tx.error);
        tx.oncomplete = () => resolve();

        const now = Date.now();
        store.put({
          id: pathToId(fullPath),
          fullPath,
          directory: parentDir,
          name,
          type: "directory",
          modified: now,
          size: 0,
        });

        // Simple fake file for now to always have at least one file in dirs
        // TODO: Remove the need for this
        const systemFile = fullPath + DIR_CONFIG_FILENAME;
        store.put({
          id: pathToId(systemFile),
          fullPath: systemFile,
          directory: fullPath,
          name: DIR_CONFIG_FILENAME,
          type: "system",
          modified: now,
          size: 0,
        });
      });
    });
  }

  _scheduleLockingOperation(operationCb) {
    return new Promise((resolve, reject) => {
      const shouldRestartQueue = this._queue.length === 0;
      const queueItem = { resolve, reject, operationCb };
      this._queue.push(queueItem);
      if (shouldRestartQueue) {
        this._performNextOperation();
      }
    });
  }

  _performNextOperation() {
    const nextOp = this._queue[0];
    if (!nextOp) {
      return;
    }
    nextOp.operationCb().then(
      (res) => {
        if (this._queue[0] === nextOp) {
          this._queue.shift();
        }
        nextOp.resolve(res);
        this._performNextOperation();
      },
      (err) => {
        if (this._queue[0] === nextOp) {
          this._queue.shift();
        }
        nextOp.reject(err);
        this._performNextOperation();
      },
    );
  }

  async _readDirEntries(dirPath) {
    if (!dirPath.endsWith("/")) {
      throw new Error("Calling stat on a directory instead of a file");
    }
    if (dirPath === "/") {
      return this._virtualRootDirs
        .map((d) => {
          return {
            id: pathToId(d),
            fullPath: d,
            directory: "/",
            name: getName(d),
            type: "directory",
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          };
        })
        .concat({
          id: pathToId(USER_DATA_DIR),
          fullPath: USER_DATA_DIR,
          directory: "/",
          name: getName(USER_DATA_DIR),
          type: "directory",
          modified: DEFAULT_MODIFIED_DATE,
          size: 0,
        });
    }
    if (this._virtualRootDirs.includes(dirPath)) {
      if (dirPath === APPS_DIR) {
        return this._apps.map((app) => {
          const name = `${app.id}.run`;
          const fullPath = APPS_DIR + name;
          return {
            id: pathToId(fullPath),
            fullPath,
            directory: APPS_DIR,
            name,
            type: "file",
            icon: app.icon,
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          };
        });
      }
      if (dirPath === SYSTEM_DIR) {
        return [
          DESKTOP_CONFIG,
          START_MENU_CONFIG,
          PROVIDERS_CONFIG,
          DEFAULT_APPS_CONFIG,
        ].map((filename) => {
          const fullPath = SYSTEM_DIR + filename;
          return {
            id: pathToId(fullPath),
            fullPath,
            directory: SYSTEM_DIR,
            name: filename,
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
            size: 0,
          };
        });
      }
      throw new Error("Invalid directory: " + dirPath);
    }

    if (!dirPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Invalid directory: " + dirPath);
    }

    const db = await this._dbProm;
    const metadataStore = db
      .transaction(METADATA_STORE, "readonly")
      .objectStore(METADATA_STORE);

    const range = IDBKeyRange.only(dirPath);

    return new Promise((resolve, reject) => {
      const request = metadataStore.index("directory").getAll(range, 100);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (request.result.length === 0) {
          if (dirPath === USER_DATA_DIR) {
            resolve([]);
          } else {
            // For now we placed a system file in all other directories
            // If we don't see it, the directory doesn't exists
            reject(new Error("Invalid directory: " + dirPath));
          }
          return;
        }
        resolve(request.result.filter((r) => r.name !== DIR_CONFIG_FILENAME));
      };
    });
  }

  async _readDirRecursive(dirPath) {
    const db = await this._dbProm;
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";

    return new Promise((resolve, reject) => {
      const transaction = db.transaction([METADATA_STORE], "readonly");
      const metadataStore = transaction.objectStore(METADATA_STORE);
      const allEntries = [];
      const request = metadataStore.openCursor();
      request.onerror = () => reject(request.error);
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const entry = cursor.value;
          if (
            entry.fullPath === normalizedDirPath ||
            entry.fullPath.startsWith(normalizedDirPath)
          ) {
            allEntries.push(entry);
          }
          cursor.continue();
        } else {
          resolve(allEntries);
        }
      };
    });
  }

  async _writeFileUnchecked(path, contentAb) {
    const name = getName(path);
    const directoryPath = getDirPath(path);

    // Delete first previous file if one
    const list = await this._readDirEntries(directoryPath);
    for (const entry of list) {
      if (entry.name === name) {
        await this._rmFileUnchecked(directoryPath + entry.name);
      }
    }

    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    const metadataStore = tx.objectStore(METADATA_STORE);
    const contentStore = tx.objectStore(CONTENT_STORE);
    const now = Date.now();
    const id = pathToId(path);
    metadataStore.put({
      id,
      fullPath: path,
      directory: directoryPath,
      name,
      size: contentAb.byteLength,
      type: "file",
      modified: now,
    });
    contentStore.put({ id, content: contentAb });

    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();
    });
  }

  async _rmFileUnchecked(filePath) {
    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();
      const id = pathToId(filePath);

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);
      metadataStore.delete(id);
      contentStore.delete(id);
    });
  }
}

const fs = new DesktopFileSystem();
export default fs;
window.fs = fs;

function openDB() {
  return new Promise((resolve, reject) => {
    // Disabling IndexedDB usage for now
    // I chose to set a dangling promise because I'm monitoring **ALL**, even
    // catched, errors to ensure I'm not doing bad stuff.
    //
    // Weird effect could be infinite loading when trying to access non-virtual
    // filesystem, but this shouldn't happen.
    //
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      const store = db.createObjectStore(METADATA_STORE, { keyPath: "id" });
      store.createIndex("directory", "directory");
      store.createIndex("fullPath", "fullPath", { unique: true });

      // Store content separately for efficiency
      db.createObjectStore(CONTENT_STORE, { keyPath: "id" });
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function getDirPath(path) {
  return path.substring(0, path.lastIndexOf("/") + 1);
}

export function getName(path) {
  const lastIndexOf = path.lastIndexOf("/");
  if (lastIndexOf === -1) {
    return "";
  }
  if (lastIndexOf === path.length - 1) {
    const substr = path.substring(0, path.length - 1);
    const newLastIndexOf = substr.lastIndexOf("/");
    if (newLastIndexOf === -1 || newLastIndexOf === substr.length - 1) {
      return "";
    }
    return path.substring(newLastIndexOf + 1, lastIndexOf);
  }
  return path.substring(lastIndexOf + 1);
}

function pathToId(path) {
  const utf8Bytes = new TextEncoder().encode(path);
  return btoa(String.fromCharCode(...utf8Bytes))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

// function idToPath(id) {
//   id = id.replace(/-/g, "+").replace(/_/g, "/");
//   const bytes = Uint8Array.from(atob(id), (c) => c.charCodeAt(0));
//   return new TextDecoder().decode(bytes);
// }

function parseToWantedFormat(data, format) {
  if (format === "arraybuffer") {
    if (typeof data === "string") {
      return textEncoder.encode(data);
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return textEncoder.encode(JSON.stringify(data, null, 2));
    } else {
      throw new Error("Impossible to parse to ArrayBuffer the wanted file");
    }
  }

  if (format === "object") {
    if (typeof data === "string") {
      return JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const decoded = textDecoder.decode(data);
      return JSON.parse(decoded);
    } else if (typeof data === "object") {
      return data;
    } else {
      throw new Error("Impossible to parse to Object the wanted file");
    }
  }

  // else this is a string that is wanted
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return textDecoder.decode(data);
  }
  return JSON.stringify(data, null, 2);
}

/**
 * Generate desktop config object depending on the generated app file.
 * @returns {Object}
 */
function generateDesktopConfig() {
  const groups = new Map();
  return {
    list: apps.reduce((acc, app) => {
      if (typeof app.desktop?.group === "string" && app.desktop.group !== "") {
        const existingGroupList = groups.get(app.desktop.group);
        const appArg = {
          type: "file",
          name: `${app.id}.run`,
          data: textEncoder.encode(JSON.stringify(app, null, 2)),
        };
        if (existingGroupList) {
          existingGroupList.push(appArg);
        } else {
          const title = app.desktop.group;
          const icon = app.desktop.group === "External Apps" ? "ðŸ“¡" : "ðŸ’½";

          const newList = [{ type: "options", icon, title }, appArg];
          groups.set(app.desktop.group, newList);
          acc.push({
            run: "/apps/app-group.run",
            args: newList,
            title,
            icon,
          });
        }
      } else if (app.desktop?.display) {
        const path = `/apps/${app.id}.run`;
        acc.push({
          run: path,
          args: [],
          title: app.title,
          icon: app.icon,
        });
      }
      return acc;
    }, []),
  };
}

/**
 * Generate start menu config object depending on the generated app file.
 * @returns {Object}
 */
function generateStartMenuConfig() {
  const lists = new Map();
  return {
    list: apps.reduce((acc, app) => {
      const path = `/apps/${app.id}.run`;
      const appObject = {
        type: "application",
        run: path,
        args: [],
        title: app.title,
        icon: app.icon,
      };
      if (
        typeof app.startMenu?.list === "string" &&
        app.startMenu.list !== ""
      ) {
        const existinglistList = lists.get(app.startMenu.list);
        if (existinglistList) {
          existinglistList.push(appObject);
        } else {
          const newList = [appObject];
          lists.set(app.startMenu.list, newList);
          acc.push({
            type: "sublist",
            name: app.startMenu.list,
            list: newList,
          });
        }
      } else if (app.desktop?.display) {
        acc.push(appObject);
      }
      return acc;
    }, []),
  };
}

/**
 * Generate config object of app "providers".
 * @returns {Object}
 */
function generateProvidersConfig() {
  return apps.reduce((acc, app) => {
    if (!Array.isArray(app.provider)) {
      return acc;
    }
    const path = `/apps/${app.id}.run`;
    for (const feature of app.provider) {
      if (acc[feature] !== undefined) {
        acc[feature].push(path);
      } else {
        acc[feature] = [path];
      }
    }
    return acc;
  }, {});
}

/**
 * Generate config object for default app per extensions.
 * @returns {Object}
 */
function generateDefaultAppsConfig() {
  return apps.reduce((acc, app) => {
    if (!Array.isArray(app.defaultForExtensions)) {
      return acc;
    }
    const path = `/apps/${app.id}.run`;
    for (const ext of app.defaultForExtensions) {
      if (acc[ext] === undefined) {
        acc[ext] = path;
      }
    }
    return acc;
  }, {});
}

function checkWrittenFilePath(path) {
  if (!path.startsWith(USER_DATA_DIR)) {
    throw new Error("Permission denied: This directory is read-only.");
  }

  if (path.endsWith("/")) {
    throw new Error("Permission denied: Expected file, got directory.");
  }

  const name = getName(path);
  if (RESERVED_NAMES.includes(name)) {
    throw new Error("Permission denied: Reserved system file name");
  }

  if (/[\x00-\x1F\x7F/\\]/.test(name) || name === "") {
    throw new Error(
      "Unauthorized file name: Please do not use control characters, slash or anti-slash characters.",
    );
  }
}

function formatWrittenFileContent(content) {
  if (typeof content === "string") {
    return textEncoder.encode(content);
  } else if (content instanceof ArrayBuffer) {
    return content;
  } else {
    throw new Error(
      "Invalid format: A file should be a string or an ArrayBuffer",
    );
  }
}

function pathJoin(...args) {
  if (args.length === 0) {
    return "";
  }
  let curr = args[0];
  for (let i = 1; i < args.length; i++) {
    const newPart = args[i];
    if (newPart.startsWith("/")) {
      curr = newPart;
    } else if (curr.endsWith("/")) {
      curr += newPart;
    } else {
      curr += "/" + newPart;
    }
  }
  return curr;
}

function getContainingDirectory(path) {
  if (path.endsWith("/")) {
    return getDirPath(path.substring(0, path.length - 1));
  }
  return getDirPath(path);
}
