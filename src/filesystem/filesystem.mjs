// TODO: Make base mostly work even without `IndexedDB` API (just do not store
// long term in that case)
// TODO: Consistency check
// TODO: Special Error objects?

// /!\ Apps file is automatically generated by the build script
import apps from "../__generated_apps.mjs";

const DB_NAME = "local_fs";
const DB_VERSION = 1;

const METADATA_STORE = "files";
const CONTENT_STORE = "files_content";

const DIR_CONFIG_FILENAME = ".dir_config";

const APPS_DIR = "/apps/";
const SYSTEM_DIR = "/system/";
const USER_DATA_DIR = "/userdata/";

const DESKTOP_CONFIG = "desktop.config.json";
const START_MENU_CONFIG = "start_menu.config.json";

const DEFAULT_MODIFIED_DATE = 1747073021004;

const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();

class DesktopFileSystem {
  constructor() {
    this._apps = apps;
    this._dbProm = openDB();
    this._virtualRootDirs = [APPS_DIR, SYSTEM_DIR];
  }

  async writeFile(path, content) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    if (path.endsWith("/")) {
      throw new Error(
        "Calling `writeFile` to write a directory. Use `mkdir` instead.",
      );
    }

    const name = getName(path);
    const directoryPath = getDirectory(path);
    if (name === DIR_CONFIG_FILENAME) {
      throw new Error("Using a reserved system name");
    }

    if (/[\x00-\x1F\x7F/\\]/.test(name)) {
      throw new Error(
        "Unauthorized file name: Please do not use control characters, slash or anti-slash characters.",
      );
    }

    let contentAb;
    if (typeof content === "string") {
      contentAb = textEncoder.encode(content);
    } else if (content instanceof ArrayBuffer) {
      contentAb = content;
    } else {
      throw new Error(
        "Invalid format: A file should be a string or an ArrayBuffer",
      );
    }

    const list = await this.readDir(directoryPath);
    for (const entry of list) {
      if (entry.name === name) {
        await this.rm(directoryPath + entry.name);
      }
    }

    // I group both metadata and content write in the same IndexedDB
    // transaction (its mechanism for consistency) to avoid desynchronization.
    // There might still be due to a browser crash or power outage but shit
    // happens.
    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    const metadataStore = tx.objectStore(METADATA_STORE);
    const contentStore = tx.objectStore(CONTENT_STORE);
    const now = Date.now();
    const id = pathToId(path);
    metadataStore.put({
      id,
      fullPath: path,
      directory: directoryPath,
      name,
      size: contentAb.byteLength,
      type: "file",
      modified: now,
    });
    contentStore.put({ id, content: contentAb });

    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();
    });
  }

  async readDir(dirPath) {
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";

    if (normalizedDirPath === "/") {
      return this._virtualRootDirs
        .map((d) => ({
          name: getName(d),
          type: "directory",
        }))
        .concat({
          name: "userdata",
          type: "directory",
        });
    }

    if (this._virtualRootDirs.includes(normalizedDirPath)) {
      if (normalizedDirPath === APPS_DIR) {
        return this._apps.map((a) => {
          return {
            name: `${a.id}.run`,
            icon: a.icon,
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
          };
        });
      }
      if (normalizedDirPath === SYSTEM_DIR) {
        return [
          {
            name: DESKTOP_CONFIG,
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
          },
          {
            name: START_MENU_CONFIG,
            type: "file",
            modified: DEFAULT_MODIFIED_DATE,
          },
        ];
      }
      throw new Error("Invalid directory: " + dirPath);
    }

    if (!normalizedDirPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Invalid directory: " + dirPath);
    }

    const db = await this._dbProm;
    const metadataStore = db
      .transaction(METADATA_STORE, "readonly")
      .objectStore(METADATA_STORE);

    const range = IDBKeyRange.only(normalizedDirPath);

    return new Promise((resolve, reject) => {
      const request = metadataStore.index("directory").getAll(range, 100);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (request.result.length === 0) {
          if (normalizedDirPath === USER_DATA_DIR) {
            resolve([]);
          } else {
            // For now we placed a system file in all other directories
            // If we don't see it, the directory doesn't exists
            reject(new Error("Invalid directory: " + dirPath));
          }
        }
        const res = [];
        for (const r of request.result) {
          if (r.name === DIR_CONFIG_FILENAME) {
            continue;
          }
          res.push({
            name: r.name,
            type: r.type,
            modified: r.modified,
          });
        }
        resolve(res);
      };
    });
  }

  async stat(filePath) {
    if (filePath.endsWith("/")) {
      throw new Error("Calling stat on a directory instead of a file");
    }
    if (filePath.startsWith(APPS_DIR)) {
      const id = filePath.substring(APPS_DIR.length, id.length - ".run".length);
      const app = this._apps.find((a) => a.id === id);
      if (!app || id.indexOf("/") >= 0) {
        throw new Error("Cannot stat file: file not found");
      }
      return {
        name: `${app.id}.run`,
        icon: app.icon,
        type: "file",
        modified: DEFAULT_MODIFIED_DATE,
      };
    }
    if (filePath.startsWith(SYSTEM_DIR)) {
      const file = filePath.substring(SYSTEM_DIR.length);
      if ([DESKTOP_CONFIG, START_MENU_CONFIG].includes(file)) {
        return {
          name: file,
          type: "file",
          modified: DEFAULT_MODIFIED_DATE,
        };
      }
    }

    if (!filePath.startsWith(USER_DATA_DIR)) {
      throw new Error("Cannot state file: file not found");
    }

    const db = await this._dbProm;
    const metadataStore = db
      .transaction(METADATA_STORE, "readonly")
      .objectStore(METADATA_STORE);

    const range = IDBKeyRange.only(filePath);

    return new Promise((resolve, reject) => {
      const request = metadataStore.index("directory").getAll(range, 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (request.result.length === 0) {
          throw new Error("Cannot state file: file not found");
        }
        resolve({
          name: request.result[0].name,
          type: request.result[0].type,
          modified: request.result[0].modified,
        });
      };
    });
  }

  async rmFile(filePath) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }
    if (path.endsWith("/")) {
      throw new Error("Writing a directory instead of a file");
    }

    // I group both metadata and content write in the same IndexedDB
    // transaction (its mechanism for consistency) to avoid desynchronization.
    // There might still be due to a browser crash or power outage but shit
    // happens.
    const db = await this._dbProm;
    const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();
      const id = pathToId(filePath);

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);
      metadataStore.delete(id);
      contentStore.delete(id);
    });
  }

  async mv(sourcePath, destinationPath) {
    if (!sourcePath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: The source directory is read-only");
    }
    if (!destinationPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const db = await this._dbProm;

    const allEntries = await this._readDirRecursive(sourcePath);
    return new Promise((resolve, reject) => {
      const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);

      allEntries.forEach((entry) => {
        const originalId = pathToId(entry.fullPath);
        let newPath;
        if (entry.fullPath === sourcePath) {
          newPath = destinationPath;
        } else {
          newPath = destinationPath + entry.fullPath.slice(sourcePath.length);
        }
        const newId = pathToId(newPath);
        metadataStore.put({
          ...dirEntry,
          id: newId,
          fullPath: newPath,
          directory: getDirectory(newPath),
          name: getName(newPath),
        });
        metadataStore.delete(originalId);

        if (entry.type !== "directory") {
          const getRequest = contentStore.get(originalId);
          getRequest.onsuccess = () => {
            if (getRequest.result) {
              contentStore.put({
                id: newId,
                content: getRequest.result.content,
              });
              contentStore.delete(originalId);
            }
          };
        }
      });
    });
  }

  async rm(path) {
    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const db = await this._dbProm;

    const allEntries = await this._readDirRecursive(path);
    return new Promise((resolve, reject) => {
      const tx = db.transaction([METADATA_STORE, CONTENT_STORE], "readwrite");
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();

      const metadataStore = tx.objectStore(METADATA_STORE);
      const contentStore = tx.objectStore(CONTENT_STORE);
      allEntries.forEach((entry) => {
        const originalId = pathToId(entry.fullPath);
        metadataStore.delete(originalId);

        if (entry.type !== "directory") {
          const getRequest = contentStore.get(originalId);
          getRequest.onsuccess = () => {
            if (getRequest.result) {
              contentStore.delete(originalId);
            }
          };
        }
      });
    });
  }

  /**
   * @param {string} path
   * @returns {Promise.<ArrayBuffer|string|Object>}
   */
  async readFile(path, format) {
    if (path.endsWith("/")) {
      throw new Error(
        "Calling `readFile` to read a directory. Use `readDir` instead.",
      );
    }

    if (path.startsWith(APPS_DIR)) {
      const wantedApp = path.substring(
        APPS_DIR.length,
        path.length - ".run".length,
      );

      // As this should be relatively frequent, we may also do a map
      // though at current scale, don't think it will have real-life impact
      for (const app of this._apps) {
        if (app.id === wantedApp) {
          return parseToWantedFormat(app, format);
        }
      }
      throw new Error("File not found: " + path);
    }

    if (path.startsWith(SYSTEM_DIR)) {
      const wantedFile = path.substring(SYSTEM_DIR.length);
      try {
        if (wantedFile === DESKTOP_CONFIG) {
          const desktopConfig = generateDesktopConfig();
          return parseToWantedFormat(desktopConfig, format);
        }
        if (wantedFile === START_MENU_CONFIG) {
          const startMenuConfig = generateStartMenuConfig();
          return parseToWantedFormat(startMenuConfig, format);
        }
      } catch (err) {
        throw new Error("Impossible to read corrupted file: " + path);
      }
      throw new Error("File not found: " + path);
    }

    if (!path.startsWith(USER_DATA_DIR)) {
      throw new Error("File not found: " + path);
    }

    const db = await this._dbProm;
    const contentStore = db
      .transaction(CONTENT_STORE, "readwrite")
      .objectStore(CONTENT_STORE);
    return new Promise((resolve, reject) => {
      const request = contentStore.get(pathToId(path));
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (!request.result) {
          reject(new Error("File not found."));
        }
        const content = request.result.content;
        try {
          resolve(parseToWantedFormat(content, format));
        } catch (err) {
          reject(err);
        }
      };
    });
  }

  async mkdir(path) {
    const fullPath = path.endsWith("/") ? path : path + "/";
    if (!fullPath.startsWith(USER_DATA_DIR)) {
      throw new Error("Permission denied: This directory is read-only");
    }

    const name = getName(fullPath);
    const parentDir = getDirectory(fullPath.substring(0, fullPath.length - 1));

    const list = await this.readDir(parentDir);
    for (const entry of list) {
      if (entry.name === name) {
        throw new Error(
          "An item with that name already exists in this directory.",
        );
      }
    }

    const db = await this._dbProm;
    const tx = db.transaction(METADATA_STORE, "readwrite");
    const store = tx.objectStore(METADATA_STORE);
    return new Promise((resolve, reject) => {
      tx.onerror = () => reject(tx.error);
      tx.oncomplete = () => resolve();

      const now = Date.now();
      store.put({
        id: pathToId(fullPath),
        fullPath,
        directory: parentDir,
        name,
        type: "directory",
        modified: now,
        size: 0,
      });

      // Simple fake file for now to always have at least one file in dirs
      // TODO: Remove the need for this
      const systemFile = fullPath + DIR_CONFIG_FILENAME;
      store.put({
        id: pathToId(systemFile),
        fullPath: systemFile,
        directory: fullPath,
        name: DIR_CONFIG_FILENAME,
        type: "system",
        modified: now,
        size: 0,
      });
    });
  }
  async _readDirRecursive(dirPath) {
    const db = await this._dbProm;
    const normalizedDirPath = dirPath.endsWith("/") ? dirPath : dirPath + "/";

    return new Promise((resolve, reject) => {
      const transaction = db.transaction([METADATA_STORE], "readonly");
      const metadataStore = transaction.objectStore(METADATA_STORE);
      const allEntries = [];
      const request = metadataStore.openCursor();
      request.onerror = () => reject(request.error);
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const entry = cursor.value;
          if (
            entry.fullPath === normalizedDirPath ||
            entry.fullPath.startsWith(normalizedDirPath)
          ) {
            allEntries.push(entry);
          }
          cursor.continue();
        } else {
          resolve(allEntries);
        }
      };
    });
  }
}

const fs = new DesktopFileSystem();
export default fs;
window.fs = fs;

function openDB() {
  return new Promise((resolve, reject) => {
    // Disabling IndexedDB usage for now
    // I chose to set a dangling promise because I'm monitoring **ALL**, even
    // catched, errors to ensure I'm not doing bad stuff.
    //
    // Weird effect could be infinite loading when trying to access non-virtual
    // filesystem, but this shouldn't happen.
    //
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      const store = db.createObjectStore(METADATA_STORE, { keyPath: "id" });
      store.createIndex("directory", "directory");
      store.createIndex("fullPath", "fullPath", { unique: true });

      // Store content separately for efficiency
      db.createObjectStore(CONTENT_STORE, { keyPath: "id" });
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function getDirectory(path) {
  return path.substring(0, path.lastIndexOf("/") + 1);
}

function getName(path) {
  return path.split("/").filter(Boolean).pop();
}

function pathToId(path) {
  const utf8Bytes = new TextEncoder().encode(path);
  return btoa(String.fromCharCode(...utf8Bytes))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

// function idToPath(id) {
//   id = id.replace(/-/g, "+").replace(/_/g, "/");
//   const bytes = Uint8Array.from(atob(id), (c) => c.charCodeAt(0));
//   return new TextDecoder().decode(bytes);
// }

function parseToWantedFormat(data, format) {
  if (format === "arraybuffer") {
    if (typeof data === "string") {
      return textEncoder.encode(data);
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return textEncoder.encode(JSON.stringify(data));
    } else {
      throw new Error(
        "Impossible to parse to ArrayBuffer the following file: " + path,
      );
    }
  }

  if (format === "object") {
    if (typeof data === "string") {
      return JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      throw new Error(
        "Impossible to parse to Object the following file: " + path,
      );
    } else if (typeof data === "object") {
      return data;
    } else {
      throw new Error(
        "Impossible to parse to Object the following file: " + path,
      );
    }
  }

  // else this is a string that is wanted
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return textDecoder.decode(data);
  }
  return JSON.stringify(data);
}

/**
 * Generate desktop config object depending on the generated app file.
 * @returns {Object}
 */
function generateDesktopConfig() {
  const groups = new Map();
  return {
    list: apps.reduce((acc, app) => {
      const path = `/apps/${app.id}.run`;
      if (typeof app.desktop?.group === "string" && app.desktop.group !== "") {
        const existingGroupList = groups.get(app.desktop.group);
        if (existingGroupList) {
          existingGroupList.push(path);
        } else {
          const title = app.desktop.group;
          const icon = app.desktop.group === "External Apps" ? "📡" : "💽";

          // app-group args are [icon, title, ...apps]
          const newList = [icon, title, path];
          groups.set(app.desktop.group, newList);
          acc.push({
            run: "/apps/app-group.run",
            args: newList,
            title,
            icon,
          });
        }
      } else if (app.desktop?.display) {
        acc.push({
          run: path,
          args: [],
          title: app.title,
          icon: app.icon,
        });
      }
      return acc;
    }, []),
  };
}

/**
 * Generate start menu config object depending on the generated app file.
 * @returns {Object}
 */
function generateStartMenuConfig() {
  const lists = new Map();
  return {
    list: apps.reduce((acc, app) => {
      const path = `/apps/${app.id}.run`;
      const appObject = {
        type: "application",
        run: path,
        args: [],
        title: app.title,
        icon: app.icon,
      };
      if (
        typeof app.startMenu?.list === "string" &&
        app.startMenu.list !== ""
      ) {
        const existinglistList = lists.get(app.startMenu.list);
        if (existinglistList) {
          existinglistList.push(appObject);
        } else {
          const newList = [appObject];
          lists.set(app.startMenu.list, newList);
          acc.push({
            type: "sublist",
            name: app.startMenu.list,
            list: newList,
          });
        }
      } else if (app.desktop?.display) {
        acc.push(appObject);
      }
      return acc;
    }, []),
  };
}
