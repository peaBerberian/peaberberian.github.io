// /!\ Apps file is automatically generated by the build script
import apps from "../__generated_apps.mjs";

export const DB_NAME = "local_fs";
export const DB_VERSION = 1;

export const METADATA_STORE = "files";
export const CONTENT_STORE = "files_content";

export const APPS_DIR = "/apps/";
export const SYSTEM_DIR = "/system/";
export const USER_DATA_DIR = "/userdata/";

export const DESKTOP_CONFIG = "desktop.config.json";
export const START_MENU_CONFIG = "start_menu.config.json";
export const PROVIDERS_CONFIG = "providers.config.json";
export const DEFAULT_APPS_CONFIG = "default_apps.config.json";

export const DIR_CONFIG_FILENAME = ".dir_config";

export const RESERVED_NAMES = [DIR_CONFIG_FILENAME, ".", ".."];

export const DEFAULT_MODIFIED_DATE = 1747073021004;

const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();

export function openDB() {
  return new Promise((resolve, reject) => {
    // Disabling IndexedDB usage for now
    // I chose to set a dangling promise because I'm monitoring **ALL**, even
    // catched, errors to ensure I'm not doing bad stuff.
    //
    // Weird effect could be infinite loading when trying to access non-virtual
    // filesystem, but this shouldn't happen.
    //
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      const store = db.createObjectStore(METADATA_STORE, { keyPath: "id" });
      store.createIndex("directory", "directory");
      store.createIndex("fullPath", "fullPath", { unique: true });

      // Store content separately for efficiency
      db.createObjectStore(CONTENT_STORE, { keyPath: "id" });
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

export function getDirPath(path) {
  return path.substring(0, path.lastIndexOf("/") + 1);
}

export function getName(path) {
  const lastIndexOf = path.lastIndexOf("/");
  if (lastIndexOf === -1) {
    return "";
  }
  if (lastIndexOf === path.length - 1) {
    const substr = path.substring(0, path.length - 1);
    const newLastIndexOf = substr.lastIndexOf("/");
    if (newLastIndexOf === -1 || newLastIndexOf === substr.length - 1) {
      return "";
    }
    return path.substring(newLastIndexOf + 1, lastIndexOf);
  }
  return path.substring(lastIndexOf + 1);
}

export function pathToId(path) {
  const utf8Bytes = new TextEncoder().encode(path);
  return btoa(String.fromCharCode(...utf8Bytes))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

// function idToPath(id) {
//   id = id.replace(/-/g, "+").replace(/_/g, "/");
//   const bytes = Uint8Array.from(atob(id), (c) => c.charCodeAt(0));
//   return new TextDecoder().decode(bytes);
// }

export function parseToWantedFormat(data, format) {
  if (format === "arraybuffer") {
    if (typeof data === "string") {
      return textEncoder.encode(data);
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return textEncoder.encode(JSON.stringify(data, null, 2));
    } else {
      throw new Error("Impossible to parse to ArrayBuffer the wanted file");
    }
  }

  if (format === "object") {
    if (typeof data === "string") {
      return JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const decoded = textDecoder.decode(data);
      return JSON.parse(decoded);
    } else if (typeof data === "object") {
      return data;
    } else {
      throw new Error("Impossible to parse to Object the wanted file");
    }
  }

  // else this is a string that is wanted
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return textDecoder.decode(data);
  }
  return JSON.stringify(data, null, 2);
}

/**
 * Generate desktop config object depending on the generated app file.
 * @returns {Object}
 */
export function generateDesktopConfig() {
  const groups = new Map();
  return {
    list: apps.reduce((acc, app) => {
      if (typeof app.desktop?.group === "string" && app.desktop.group !== "") {
        const existingGroupList = groups.get(app.desktop.group);
        const appArg = {
          path: `/apps/${app.id}.run`,
          title: app.title,
          icon: app.icon,
        };
        if (existingGroupList) {
          existingGroupList.push(appArg);
        } else {
          const title = app.desktop.group;
          const icon = app.desktop.group === "External Apps" ? "ðŸ“¡" : "ðŸ’½";

          const newList = [appArg];
          groups.set(app.desktop.group, newList);
          acc.push({
            run: "/apps/app-group.run",
            args: [{ type: "options", icon, title, apps: newList }],
            title,
            icon,
          });
        }
      } else if (app.desktop?.display) {
        const path = `/apps/${app.id}.run`;
        acc.push({
          run: path,
          args: [],
          title: app.title,
          icon: app.icon,
        });
      }
      return acc;
    }, []),
  };
}

/**
 * Generate start menu config object depending on the generated app file.
 * @returns {Object}
 */
export function generateStartMenuConfig() {
  const lists = new Map();
  return {
    list: apps.reduce((acc, app) => {
      const path = `/apps/${app.id}.run`;
      const appObject = {
        type: "application",
        run: path,
        args: [],
        title: app.title,
        icon: app.icon,
      };
      if (
        typeof app.startMenu?.list === "string" &&
        app.startMenu.list !== ""
      ) {
        const existinglistList = lists.get(app.startMenu.list);
        if (existinglistList) {
          existinglistList.push(appObject);
        } else {
          const newList = [appObject];
          lists.set(app.startMenu.list, newList);
          acc.push({
            type: "sublist",
            name: app.startMenu.list,
            list: newList,
          });
        }
      } else if (app.startMenu?.display) {
        acc.push(appObject);
      }
      return acc;
    }, []),
  };
}

/**
 * Generate config object of app "providers".
 * @returns {Object}
 */
export function generateProvidersConfig() {
  return apps.reduce((acc, app) => {
    if (!Array.isArray(app.provider)) {
      return acc;
    }
    const path = `/apps/${app.id}.run`;
    for (const feature of app.provider) {
      if (acc[feature] !== undefined) {
        acc[feature].push(path);
      } else {
        acc[feature] = [path];
      }
    }
    return acc;
  }, {});
}

/**
 * Generate config object for default app per extensions.
 * @returns {Object}
 */
export function generateDefaultAppsConfig() {
  return apps.reduce((acc, app) => {
    if (!Array.isArray(app.defaultForExtensions)) {
      return acc;
    }
    const path = `/apps/${app.id}.run`;
    for (const ext of app.defaultForExtensions) {
      if (acc[ext] === undefined) {
        acc[ext] = path;
      }
    }
    return acc;
  }, {});
}

export function checkWrittenFilePath(path) {
  if (!path.startsWith(USER_DATA_DIR)) {
    throw new Error("Permission denied: This directory is read-only.");
  }

  if (path.endsWith("/")) {
    throw new Error("Permission denied: Expected file, got directory.");
  }

  const name = getName(path);
  if (RESERVED_NAMES.includes(name)) {
    throw new Error("Permission denied: Reserved system file name");
  }

  if (/[\x00-\x1F\x7F/\\]/.test(name) || name === "") {
    throw new Error(
      "Unauthorized file name: Please do not use control characters, slash or anti-slash characters.",
    );
  }
}

export function formatWrittenFileContent(content) {
  if (typeof content === "string") {
    return textEncoder.encode(content);
  } else if (content instanceof ArrayBuffer) {
    return content;
  } else {
    throw new Error(
      "Invalid format: A file should be a string or an ArrayBuffer",
    );
  }
}

export function pathJoin(...args) {
  if (args.length === 0) {
    return "";
  }
  let curr = args[0];
  for (let i = 1; i < args.length; i++) {
    const newPart = args[i];
    if (newPart.startsWith("/")) {
      curr = newPart;
    } else if (curr.endsWith("/")) {
      curr += newPart;
    } else {
      curr += "/" + newPart;
    }
  }
  return curr;
}

export function getContainingDirectory(path) {
  if (path.endsWith("/")) {
    return getDirPath(path.substring(0, path.length - 1));
  }
  return getDirPath(path);
}
